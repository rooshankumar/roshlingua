Perfect! Thatâ€™s exactly how a well-structured onboarding flow should behave.

Hereâ€™s how to implement it step-by-step in a Supabase + React + React Router app:

âœ… Flow You Want:
User logs in using Google

If it's a new user, theyâ€™re redirected to /onboarding

If onboarding is already completed, go to /dashboard

âœ… Step-by-Step Setup
ğŸ”¹ 1. Login Button (Start OAuth Flow)
tsx
Copy
Edit
// Login.tsx
import { supabase } from "@/lib/supabase";

const handleGoogleLogin = async () => {
  await supabase.auth.signInWithOAuth({
    provider: "google",
    options: {
      redirectTo: "https://roshlingua.vercel.app/auth/callback",
    },
  });
};
ğŸ”¹ 2. Callback Page (/auth/callback)
This handles:

Exchanging the code

Checking onboarding status

Redirecting accordingly

tsx
Copy
Edit
// AuthCallback.tsx
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { supabase } from "@/lib/supabase";
import { useToast } from "@/hooks/use-toast";

const AuthCallback = () => {
  const navigate = useNavigate();
  const { toast } = useToast();

  useEffect(() => {
    const handleAuth = async () => {
      try {
        const code = new URLSearchParams(window.location.search).get("code");
        if (!code) throw new Error("No authorization code found in URL.");

        // Exchange code for session
        const { data: sessionData, error: sessionError } =
          await supabase.auth.exchangeCodeForSession(code);

        if (sessionError || !sessionData.session) {
          throw new Error(sessionError?.message || "Failed to establish session.");
        }

        const userId = sessionData.session.user.id;

        // Fetch profile from 'profiles' table (must be created manually)
        const { data: profile, error: profileError } = await supabase
          .from("profiles")
          .select("onboarding_completed")
          .eq("user_id", userId)
          .single();

        if (profileError) {
          console.warn("Profile not found, treating as new user.");
          // Optionally insert a new empty profile for the new user
          await supabase.from("profiles").insert([{ user_id: userId }]);
          return navigate("/onboarding", { replace: true });
        }

        const redirectTo = profile?.onboarding_completed ? "/dashboard" : "/onboarding";
        navigate(redirectTo, { replace: true });

      } catch (error: any) {
        console.error("Auth error:", error);
        toast({
          variant: "destructive",
          title: "Authentication Failed",
          description: error.message || "Something went wrong.",
        });

        setTimeout(() => navigate("/auth", { replace: true }), 2000);
      }
    };

    handleAuth();
  }, [navigate, toast]);

  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="text-center space-y-2">
        <h2 className="text-2xl font-semibold">Signing you in...</h2>
        <p className="text-muted-foreground">Please wait.</p>
      </div>
    </div>
  );
};

export default AuthCallback;
ğŸ”¹ 3. Supabase profiles Table (Required)
Make sure youâ€™ve created a profiles table in Supabase like this:

Column Name	Type
user_id	UUID (Primary Key)
onboarding_completed	boolean
...	any extras
user_id must match the Supabase auth.users.id

You can use Supabase Row-Level Security (RLS) with policies like:

sql
Copy
Edit
-- Allow logged in user to read/update their profile
CREATE POLICY "Logged in user can access own profile"
  ON profiles
  FOR SELECT, UPDATE, INSERT
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
âœ… Done! Youâ€™re good.
ğŸ” Every new Google user will land on /onboarding. Once they finish onboarding, update onboarding_completed = true. The next time, theyâ€™ll go to /dashboard.

